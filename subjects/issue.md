# Push Swap

## ISSUEは？
> どうすれば、与えられたスタックを、**最小限の操作**でソートできるか？

---

## データ構造とアルゴリズムの選択

### データ構造について
- **int 配列**
  - メリット：ランダムアクセスが O(1)、メモリ連続でキャッシュ効率が高い
  - デメリット：先頭・末尾以外への挿入・削除が O(n)
- **双方向リンクドリスト**
  - メリット：任意の位置での push/pop が O(1)、rotate（回転）操作が直感的
  - デメリット：ランダムアクセスが O(n)、ポインタ管理のバグリスク

→ **選択基準**
- 小規模（≤ 5 要素）は配列で全列挙ソート
- 中規模（6～100 要素）はリスト＋チャンク分割
- 大規模（101～500 要素）はリスト＋ビット基数ソート風

---

## サイズ別アルゴリズム（MECEを満たす）

### 1. 要素数 ≤ 5 のとき
- **手法**：ソートネットワーク or 全探索
- **理由**：操作の最適手順を事前列挙可能。
- **手順例**：
  1. 全通りの操作シーケンス（最大 12 操作程度）をあらかじめ定義
  2. 入力にマッチするパターンを適用

### 2. 6 ～ 100 要素 のとき
- **手法**：チャンク分割＋挿入ソート風戦略
- **理由**：
  - 要素をいくつかのチャンクに分け、
  - Stack B 側に小さい順でプッシュし、再度 Stack A に戻す
- **手順概要**：
  1. 全要素をソートしたときのインデックス（順位）でチャンク化
  2. チャンクごとに B へ pb しつつ，最適な位置に回転
  3. B のトップから A へ pa で戻す

### 3. 101 ～ 500 要素 のとき
- **手法**：ビット基数ソート（Radix Sort）風
- **理由**：
  - ビット単位で全体を何度かスキャンして O(n) 操作数に近づける
- **手順概要**：
  1. 最下位ビットから順に、
     - 0 ビットなら pb、1 ビットなら ra
  2. 全ビット処理後、B を pa で全戻し
  3. 必要ビット数は ⌈log₂n⌉ 回

---

## 実装



### ディレクトリ構成例


push_swap プロジェクト仕様まとめ
1. プログラム概要
プログラム名：push_swap
目的：与えられたスタック（整数列）を最小限の操作でソートし、その操作手順を表示する。
2. 提出物
Makefile（ターゲット：NAME, all, clean, fclean, re）
ソースファイル：*.c
ヘッダファイル：*.h
禁止事項：グローバル変数の使用
3. 動作仕様
3.1 引数
コマンドライン引数として整数列を受け取る
最初の引数がスタックの一番上になる点に注意
引数なしの場合：何も表示せず終了
3.2 出力
ソートに必要な操作（sa, pb, ra など）の最短シーケンスを \n 区切りで標準出力
エラー時：Error\n を標準エラーに表示
3.3 使用可能な外部関数
システム：read, write, malloc, free, exit
フォーマット出力：ft_printf など自作可
libft の利用は可
4. 動作例
チェッカー連携
checker_OS は提供バイナリ
5. ベンチマーク要件
データ数	最大操作数（100%）	最低ライン（80%）
100 要素	< 700	< 1,100 または < 700
500 要素	< 5,500	< 8,500 または < 11,500
100% 達成：100要素<700 & 500要素<5,500
80% 達成：上記いずれかの組み合わせ
6. ボーナス要件（checker プログラム）
プログラム名：checker
引数：ソート対象の整数列
標準入力で操作を受け取り実行
結果表示：
ソート成功かつスタックBが空 → OK\n
それ以外 → KO\n
エラー → Error\n （無効引数・重複・不正命令など）
提出物：Makefile（bonusターゲット）、*.c, *.h
以上を踏まえ、まずは Makefile の骨子 → 引数パース＆エラー処理 → データ構造＋基本操作 → 各規模アルゴリズム → テスト & ベンチマーク の順で実装を進めましょう。
